MHRDsavestate
Â¬Ã­ï¿½srï¿½java.util.HashMapÃšÃÃƒ`Ã‘ï¿½Fï¿½
loadFactorIï¿½	thresholdxp?@ï¿½ï¿½ï¿½ï¿½ï¿½0wï¿½ï¿½ï¿½@ï¿½ï¿½ï¿½.tï¿½RAM4W16Bsrï¿½model.DesignK+Â±4Ã©â€žÅ¡Ã£ï¿½	Zï¿½	completedZï¿½customLï¿½briefingtï¿½Ljava/lang/String;Lï¿½codeqï¿½~ï¿½Lï¿½ifaceqï¿½~ï¿½Lï¿½nameqï¿½~ï¿½Lï¿½specqï¿½~ï¿½Lï¿½statstï¿½Ljava/lang/Object;Lï¿½testsqï¿½~ï¿½xpï¿½ptâ€ Inputs: in[16], load, address[2];
Outputs: out[16];

Parts: ADEMUX1 DEMUX, BDEMUX1 DEMUX, CDEMUX1 DEMUX, DAND4B1 AND4B, 
  EREG00 REGISTER16B, EREG01 REGISTER16B, EREG10 REGISTER16B, EREG11 REGISTER16B,
  FMUX4W16B1 MUX4W16B;

Wires: 
  1->ADEMUX1.in, address[2]->ADEMUX1.sel,
  
  ADEMUX1.out1->BDEMUX1.in, address[1]->BDEMUX1.sel,
  
  ADEMUX1.out2->CDEMUX1.in, address[1]->CDEMUX1.sel,
  
  BDEMUX1.out1->DAND4B1.in1[4], BDEMUX1.out2->DAND4B1.in1[3],
  CDEMUX1.out1->DAND4B1.in1[2], CDEMUX1.out2->DAND4B1.in1[1], load->DAND4B1.in2,
  
  in->EREG00.in, DAND4B1.out[4]->EREG00.load,
  in->EREG01.in, DAND4B1.out[3]->EREG01.load,
  in->EREG10.in, DAND4B1.out[2]->EREG10.load,
  in->EREG11.in, DAND4B1.out[1]->EREG11.load,
  
  EREG00.out->FMUX4W16B1.in1, EREG01.out->FMUX4W16B1.in2,
  EREG10.out->FMUX4W16B1.in3, EREG11.out->FMUX4W16B1.in4,address->FMUX4W16B1.sel,

  FMUX4W16B1.out->out
;












tï¿½3Inputs: in[16], load, address[2];
Outputs: out[16];qï¿½~ï¿½tQ4-Register 16-Bit RAM Specification
===================================

Description:
------------
The RAM4W16B is a random access memory with 4 addressable registers and 16-bit bus width. In addition to a regular register, the RAM4W16B can save and retrieve 4 different values, which can be addressed via the address input bus.

Interface Specification:
------------------------
Inputs: in[16], load, address[2];
Outputs: out[16];


Graphical Representation:
-------------------------
          __________
         |          |
-in[16]--| RAM4W16B |--out[16]-
         |__________|
            | |
-----load---/ |
-address[2]---/

Example:
--------
 in     | address | load || out
 -------------------------------------
 0x5555 | 00      | 1    || 0x0000
 0x0000 | 00      | 0    || 0x5555
 0x0000 | 01      | 0    || 0x0000
 0xFFFF | 01      | 1    || 0x0000
 0x0000 | 01      | 0    || 0xFFFF
 0xAAAA | 10      | 1    || 0x0000
 0x0FF0 | 11      | 1    || 0x0000
 0x0000 | 00      | 0    || 0x5555
 0x0000 | 01      | 0    || 0xFFFF
 0x0000 | 10      | 0    || 0xAAAA
 0x0000 | 11      | 0    || 0x0FF0pptï¿½
REGISTER4Bsqï¿½~ï¿½ï¿½ptâ€“//Logic: if load=0, DFF.out->DFF.in // load->NOT1, (NOT1,DFF1)->AND1,
//       if load=1, in->DFF.in      // (load, in)->AND2,
//                                  // (AND1, AND2)->OR1, OR1->DFF1
//                                  // DFF1->out 
// 1 NOT, 2 ANDs, 1 OR, 1 DFF

Inputs: in[4], load;
Outputs: out[4];

// 1. specify the components you want to use here
Parts: NOT1A NOT, AND2A AND4B, AND2B AND4B, OR3A OR4B, DFF4A DFF, DFF4B DFF, 
  DFF4C DFF, DFF4D DFF;

// 2. wire them up
Wires: 
  load->NOT1A.in,
  
  DFF4A.out->AND2A.in1[4], DFF4B.out->AND2A.in1[3], 
  DFF4C.out->AND2A.in1[2], DFF4D.out->AND2A.in1[1], NOT1A.out->AND2A.in2, 
  in->AND2B.in1, load->AND2B.in2,
  
  AND2A.out->OR3A.in1, AND2B.out->OR3A.in2,
  
  OR3A.out[4]->DFF4A.in, OR3A.out[3]->DFF4B.in, OR3A.out[2]->DFF4C.in,
  OR3A.out[1]->DFF4D.in,
  
  DFF4A.out->out[4], DFF4B.out->out[3], DFF4C.out->out[2], DFF4D.out->out[1] 
;











tï¿½%Inputs: in[4], load;
Outputs: out[4];qï¿½~ï¿½
tC4-Bit Register Specification
============================

Description:
------------
The REGISTER4B is a bus version of the REGISTER element.

Interface Specification:
------------------------
Inputs: in[4], load;
Outputs: out[4];


Graphical Representation:
-------------------------
         _______
        |       |
-in[4]--| REG4B |--out[4]-
        |_______|
            |
-----load---/


Example:
--------
 in   | load || out
 -------------------
 0101 | 0    || 0000
 1010 | 0    || 0000
 0101 | 1    || 0000
 1010 | 0    || 0101
 1111 | 1    || 0101
 0000 | 0    || 1111pptï¿½OR16Bsqï¿½~ï¿½ï¿½pppqï¿½~ï¿½t"16-Bit Or Specification
=======================

Description:
------------
The OR16B element is a bus version of the OR gate. It applies the OR-operation to each pair of bits from both inputs.  


Interface Specification:
------------------------
Inputs: in1[16], in2[16];
Outputs: out[16];pptï¿½DFFsqï¿½~ï¿½ï¿½pppqï¿½~ï¿½tÂºD-Flip-Flop Specification
=========================

Description:
------------
The DFF element saves the value it receives on its input and outputs that value one clock cycle later. Its behavior can be described as out(t)=in(t-1).
The property to maintain a state across a clock cycle makes the DFF element the base of all memory elements.
Check out the the manual chapter about sequential logic.

Interface Specification:
------------------------
Inputs: in;
Outputs: out;


Graphical Representation:
-------------------------
      _____
     |     |
-in--| DFF |--out-
     |_____|


Example:
--------
 in  || out
 ----------
 0   || 0
 1   || 0
 1   || 1
 0   || 1
 0   || 0
 1   || 0
 1   || 1pptï¿½	FULLADDERsqï¿½~ï¿½ï¿½ptï¿½// 1 XOR, 2 NOTs, 7 ANDs, 3 ORs

Inputs: carryIn, in1, in2;

Outputs: out, carryOut;

// 1. specify the components you want to use here
Parts: XOR1A XOR, NOT1B NOT, AND1C AND, OR1D OR, NOT1E NOT,
       AND2A AND, AND2B AND, AND2C AND, AND2D AND,
       OR3A OR, OR3B OR
  ;

// 2. wire them up
Wires: 
  in1->XOR1A.in1, in2->XOR1A.in2, XOR1A.out->NOT1B.in,
  in1->AND1C.in1, in2->AND1C.in2, in1->OR1D.in1, in2->OR1D.in2,
  carryIn->NOT1E.in,

  XOR1A.out->AND2A.in1, NOT1E.out->AND2A.in2,
  NOT1B.out->AND2B.in1, carryIn->AND2B.in2,
  AND1C.out->AND2C.in1, NOT1E.out->AND2C.in2,
  OR1D.out->AND2D.in1, carryIn->AND2D.in2,
  
  AND2A.out->OR3A.in1, AND2B.out->OR3A.in2,
  AND2C.out->OR3B.in1, AND2D.out->OR3B.in2,
  
  OR3A.out->out, OR3B.out->carryOut
  
;










tï¿½2Inputs: carryIn, in1, in2;
Outputs: out, carryOut;qï¿½~ï¿½t)Full Adder Specification
========================

Description:
------------
The FULLADDER is only different to the HALFADDER in that it has an additional input called "carry in". The resulting sum is the sum of all three input bits. In contrast to the HALFADDER, chaining multiple FULLADDERS enables you to sum up numbers bigger than 1 bit.
Check the appendix in the manual for binary notation of numbers and binary arithmetics.


Interface Specification:
------------------------
Inputs: carryIn, in1, in2;
Outputs: out, carryOut;


Graphical Representation:
-------------------------
-carryIn--\
         _|__
---in1--|    |
        | FA |--out----
---in2--|____|
           |
           \--carryOut-


Truth Table:
------------
 carryIn | in1 | in2 || out | carryOut
 -------------------------------------
 0       | 0   | 0   || 0   | 0
 0       | 0   | 1   || 1   | 0
 0       | 1   | 0   || 1   | 0
 0       | 1   | 1   || 0   | 1
 1       | 0   | 0   || 1   | 0
 1       | 0   | 1   || 0   | 1
 1       | 1   | 0   || 0   | 1
 1       | 1   | 1   || 1   | 1pptï¿½CPUsqï¿½~ï¿½ï¿½ptÂºInputs: instr[16], data[16], reset;
Outputs: write, dataAddr[16], instrAddr[16], result[16];
Parts: decoder DECODER, mReg REGISTER16B, aReg REGISTER16B, pc COUNTER16B, 
 alu ALU16B, muxCtLm MUX4W16B, muxArCo MUX16B, muxCoArMrDa MUX4W16B, andJmZe AND;

Wires: 
 instr->decoder.instr,
// 1 cToM & loadM == 1, decoder.constant -> mReg
// 2 loadM == 1 & ctom == 0, alu.out -> mReg
 decoder.cToM->muxCtLm.sel[1], decoder.loadM->muxCtLm.sel[2], //cToM & loadM chk
 decoder.constant->muxCtLm.in4[1:15], alu.out->muxCtLm.in3, //cToM & loadM val
 muxCtLm.out->mReg.in, decoder.loadM->mReg.load,// load output to mReg
// 3 loada == 1, alu.result -> aReg
 alu.out->aReg.in, decoder.loadA->aReg.load,
// 4 decoder.loadD -> write
 decoder.loadD->write,
// 5 decoder.opcode -> alu.opcode
 decoder.opCode->alu.opCode,
// 6 decoder.op1 == 1, decoder.constant -> alu.op1[1:5], else aReg -> alu.op1
 aReg.out->muxArCo.in1, decoder.constant[1:5]->muxArCo.in2[1:5], 
 decoder.op1->muxArCo.sel, muxArCo.out->alu.in1,
// 7 decoder.op2 == 00, decoder.constant -> alu.op2[1:5]
//               == 01, aReg.out         -> alu.op2
//               == 10, mReg.out         -> alu.op2
//               == 11, data             -> alu.op2
 decoder.op2->muxCoArMrDa.sel, decoder.constant[1:5]->muxCoArMrDa.in1[1:5], 
 aReg.out->muxCoArMrDa.in2, mReg.out->muxCoArMrDa.in3, data->muxCoArMrDa.in4,
 muxCoArMrDa.out->alu.in2,
// 8 decoder.jmpifz & alu.zero == 1, mReg.out -> pc.in
 decoder.jmpIfZ->andJmZe.in1, alu.zero->andJmZe.in2, andJmZe.out->pc.load,
 mReg.out->pc.in,  
// 9 alu.out -> result
 alu.out->result,
//10 mReg.out -> dataAddr
 mReg.out->dataAddr,
//11 pc.out -> instrAddr
 pc.out->instrAddr,
//12 reset == 1, 0 -> pc.in
 reset->pc.reset;  
tï¿½\Inputs: instr[16], data[16], reset;
Outputs: write, dataAddr[16], instrAddr[16], result[16];qï¿½~ï¿½tÂ²Microhard Central Processing Unit Specification
===============================================

Description:
------------
On a high level the Microhard CPU is able to perform a wide variety of instructions similar to the Microhard ALU. However while the ALU is only capable of executing single arithmetic instructions, the CPU is able to execute complex programs composed of many instructions by managing the program execution flow.


Interface Specification:
------------------------
Inputs: instr[16], data[16], reset;
Outputs: write, dataAddr[16], instrAddr[16], result[16];


Graphical Representation:
-------------------------
             _____
-instr[16]--|     |--instrAddr[16]-
            |     |
--data[16]--| CPU |--dataAddr[16]--
            |     |--result[16]----
            |_____|--write---------
               |
-------reset---/


User Instructions:
------------------
To execute a program the CPU needs to be connected to a RAM element containing the instructions of the program and a second RAM element containing all data which should be processed.

The program RAM element has to be connected to the CPU via the "instr" and "instrAddr" busses. The "in" bus and the "load" input of the RAM is supposed to be disconnected.

The data RAM element has to be connected to the CPU via the "data" and "dataAddr" busses. The "in" bus of the RAM has to be connected to the "result" output of the CPU and the "load" input of the RAM has to be connected to the "write" output of the CPU.

To start the program, the reset pin has to be supplied with the value "1" for a single clock cycle to make sure the program is executed from the beginning.


Implementation Details:
-----------------------
The CPU contains (among other elements) two registers, one counter and one ALU:
- the Arithmetic-Register (AR) is used to temporarily store computation results
- the Memory-Register (MR) is used to reference addresses in the connected data
  RAM
- the Program-Counter (PC) is used to reference addresses in the connected
  instruction RAM
- the ALU is used to perform arithmetic operations

This specification will refer to the elements as AR, MR, PC and ALU.


Behavioral Specification:
-------------------------
After the instruction has been decoded by the DECODER (see the DECODER specification for details), the CPU uses the DECODER outputs to ensure following behavior:

- If the "cToM" and "loadM" output of the decoder is "1", the "constant" output
  has to be loaded into the MR.
- If "loadM" is "1" and "cToM" is "0", the result of the ALU operation has to be
  loaded into the MR.
- If "loadA" is "1", the result of the ALU operation has to be loaded into the
  AR.
- The "write" output of the CPU has to have the same value as the "loadD" output
  of the DECODER.
- The "opCode" output of the DECODER has to be directly fed into the ALU.
- If the "op1" output of the DECODER is "1", the "constant" has to be fed in to
  the ALU as the first operand. Otherwise the AR has to be fed into the ALU.
- For the "op2" output of the DECODER:
  "00" -> feed "constant" as second operator into the ALU
  "01" -> feed AR as second operator into the ALU
  "10" -> feed MR as second operator into the ALU
  "11" -> feed data bus as second operator into the ALU
- When feeding "constant" as an operand to the ALU, only the lowest 5 bits of "constant" are used. This 5 bit value is padded to 16 bit in accordance to the sign of the value. 
- If "jmpIfZ" and the "zero" flag of the ALU is "1", load the value of the MR
  into the PC.
- Write the ALU output on the "result" bus.
- Write the MR value on the "dataAddr" bus.
- Write the PC value on the "instrAddr" bus.
- Set the PC to "0" if the "reset" input is set.


Examples:
---------
 instr  | data   | reset || instrAddr | dataAddr | result  | write
 -----------------------------------------------------------------
 // result = const + AR = ? (unknown register states):
 0x0000 | 0x0000 | 0     || x         | x        | x       | 0
 // reset program counter: 
 0x0000 | 0x0000 | 1     || x         | x        | x       | 0
 // load 0x00FF into MR:
 0x80FF | 0x0000 | 0     || 0x0000    | x        | x       | 0
 // AR = const + data = 1 + 0 = 1:
 0x3C01 | 0x0000 | 0     || 0x0001    | 0x00FF   | 0x0001  | 0
 // result = AR + const = 1:
 0x0000 | 0x0000 | 0     || 0x0002    | 0x00FF   | 0x0001  | 0
 // MR = AR + const = 1:
 0x4000 | 0x0000 | 0     || 0x0003    | 0x00FF   | 0x0001  | 0
 // data = const + MR = 1:
 0x7800 | 0x0000 | 0     || 0x0004    | 0x0001   | 0x0001  | 1
 // load MR into PC:
 0x1020 | 0x0001 | 0     || 0x0005    | 0x0001   | 0x0000  | 0
 // no operation:
 0x1000 | 0x0001 | 0     || 0x0001    | 0x0001   | 0x0000  | 0
 // no operation:
 0x1000 | 0x0001 | 0     || 0x0002    | 0x0001   | 0x0000  | 0pptï¿½XOR16Bsqï¿½~ï¿½ï¿½pppqï¿½~ï¿½t)16-Bit X-Or Specification
=========================

Description:
------------
The XOR16B element is a bus version of the XOR gate. It applies the XOR-operation to each pair of bits from both inputs.  


Interface Specification:
------------------------
Inputs: in1[16], in2[16];
Outputs: out[16];pptï¿½NANDsqï¿½~ï¿½ï¿½pppqï¿½~ï¿½"tfNand Specification
==================

Description:
------------
The NAND gate (short for Not-And) has two inputs and one output. If both inputs are 1, the output is 0. Otherwise the output is 1. 
The NAND gate is the most basic element. It can be used to build _all_ other elements.


Interface Specification:
------------------------
Inputs: in1, in2;
Outputs: out;


Graphical Representation:
-------------------------
       ______
-in1--|      |
      | NAND |--out-
-in2--|______|


Truth Table:
------------
 in1 | in2 || out
 ----------------
 0   | 0   || 1
 0   | 1   || 1
 1   | 0   || 1
 1   | 1   || 0pptï¿½NAND16Bsqï¿½~ï¿½ï¿½pppqï¿½~ï¿½%t,16-Bit Nand Specification
=========================

Description:
------------
The NAND16B element is a bus version of the NAND gate. It applies the Nand-operation to each pair of bits from both inputs.  


Interface Specification:
------------------------
Inputs: in1[16], in2[16];
Outputs: out[16];pptï¿½DEMUXsqï¿½~ï¿½ï¿½ptï¿½Ã¥Inputs: in, sel;
Outputs: out1, out2;
Parts: NOT1 NOT, AND1 AND, AND2 AND;

Wires: 
  sel->NOT1.in, NOT1.out->AND1.in1, in->AND1.in2, AND1.out->out1,
  sel->AND2.in1, in->AND2.in2, AND2.out->out2
;































tï¿½%Inputs: in, sel;
Outputs: out1, out2;qï¿½~ï¿½(tÃ¸Demultiplexer Specification
===========================

Description:
------------
The DEMUX element has one data input, one select input and two data outputs. If the select input is 0, the data is transfered to the first output. Otherwise the data is transfered to the second output. The value of the output not taking the data bit value, is always zero. 


Interface Specification:
------------------------
Inputs: in, sel;
Outputs: out1, out2;


Graphical Representation:
-------------------------
       ______
      /      |--out1-
-in--| DEMUX |
      \______|--out2-
         |
-sel-----/

Truth Table:
------------
 sel | in || out1 | out2
 -----------------------
 0   | 0  || 0    | 0
 0   | 1  || 1    | 0
 1   | 0  || 0    | 0
 1   | 1  || 0    | 1pptï¿½MUX4W16Bsqï¿½~ï¿½ï¿½pppqï¿½~ï¿½-tâ€¹4-Way 16-Bit Multiplexer Specification
======================================

Description:
------------
The MUX4W16B element is a bus version of the MUX gate. It transfers the complete data of one of four input busses to the output bus, but otherwise behaves identically. 


Interface Specification:
------------------------
Inputs: in1[16], in2[16], in3[16], in4[16], sel[2];
Outputs: out[16];pptï¿½REGISTER16Bsqï¿½~ï¿½ï¿½pppqï¿½~ï¿½0tï¿½Ã¡16-Bit Register Specification
=============================

Description:
------------
The REG16B is a bus version of the REG element.

Interface Specification:
------------------------
Inputs: in[16], load;
Outputs: out[16];pptï¿½OR4Bsqï¿½~ï¿½ï¿½pppqï¿½~ï¿½3tÂ³4-Bit Or Specification
======================

Description:
------------
The OR4B element is a bus version of the OR gate. It applies the OR-operation to each pair of bits from both inputs.  


Interface Specification:
------------------------
Inputs: in1[4], in2[4];
Outputs: out[4];


Graphical Representation:
-------------------------
          ______
-in1[4]--|      |
         | OR4B |--out[4]-
-in2[4]--|______|


Examples:
---------
 in1  | in2  || out
 -------------------
 0000 | 0000 || 0000
 0000 | 0101 || 0101
 0000 | 1010 || 1010
 0000 | 1111 || 1111
 0101 | 0101 || 0101
 0101 | 1010 || 1111
 0101 | 1111 || 1111
 1010 | 1010 || 1010
 1010 | 1111 || 1111
 1111 | 1111 || 1111pptï¿½MUX4Bsqï¿½~ï¿½ï¿½ptvInputs: in1[4], in2[4], sel;
Outputs: out[4];

Parts: 
  NAND1 NAND, AND1 AND, AND4B2 AND4B, AND4B3 AND4B, OR4B1 OR4B
;

Wires: 
  sel->NAND1.in1, sel->NAND1.in2,
  NAND1.out->AND4B2.in1, in1->AND4B2.in2,
  
  sel->AND1.in1, sel->AND1.in2, 
  AND1.out->AND4B3.in1, in2->AND4B3.in2,
  
  AND4B2.out->OR4B1.in1, AND4B3.out->OR4B1.in2,
  OR4B1.out->out
;






















tï¿½-Inputs: in1[4], in2[4], sel;
Outputs: out[4];qï¿½~ï¿½6tx4-Bit Multiplexer Specification
===============================

Description:
------------
The MUX4B element is a bus version of the MUX gate. It transfers the whole data of one of the input busses to the output bus, but otherwise behaves identically. 


Interface Specification:
------------------------
Inputs: in1[4], in2[4], sel;
Outputs: out[4];


Graphical Representation:
-------------------------
          ____
-in1[4]--|    \
         | MUX |--out[4]-
-in2[4]--|____/
           |
-sel-------/


Examples:
---------
 sel | in1  | in2  || out
 -------------------------
 0   | 1010 | 0101 || 1010
 1   | 1010 | 0101 || 0101pptï¿½	COUNTER4Bsqï¿½~ï¿½ï¿½ptInputs: in[4], load, reset;
Outputs: out[4];

Parts: ANOT1 NOT, AOR1 OR, ANOT2 NOT, AMUX4B1 MUX4B,
       BA4B1 ADDER4B, BNAND4B1 NAND4B, BOR4W1 OR4W, BMUX4B1 MUX4B,
       COR1 OR, CNOT1 NOT, CMUX4B1 MUX4B,
       DREG4B REGISTER4B;

Wires: 
  reset->AOR1.in1, load->ANOT1.in, ANOT1.out->AOR1.in2, AOR1.out->ANOT2.in,
  ANOT2.out->AMUX4B1.sel, 0000->AMUX4B1.in1, in->AMUX4B1.in2,
  
  DREG4B.out->BA4B1.in1, 0001->BA4B1.in2, DREG4B.out->BNAND4B1.in1, 
  1111->BNAND4B1.in2, 0000->BMUX4B1.in1, BA4B1.out->BMUX4B1.in2, 
  BNAND4B1.out->BOR4W1.in, BOR4W1.out->BMUX4B1.sel,
  
  AMUX4B1.out->CMUX4B1.in1, BMUX4B1.out->CMUX4B1.in2, reset->COR1.in1, 
  load->COR1.in2, COR1.out->CNOT1.in, CNOT1.out->CMUX4B1.sel,
  
  CMUX4B1.out->DREG4B.in, 1->DREG4B.load,
  
  DREG4B.out->out

;















tï¿½,Inputs: in[4], load, reset;
Outputs: out[4];qï¿½~ï¿½;tÃ©4-Bit Counter Specification
===========================

Description:
------------
The COUNTER4B element is similiar to an REGISTER4B, with two differences.
First: For every clock cycle the load flag is 0, the internal value increments.
Second: It has an additional reset input flag. If it is 1 the internal value has to be set to "0000".

Interface Specification:
------------------------
Inputs: in[4], load, reset;
Outputs: out[4];


Graphical Representation:
-------------------------
         ___________
        |           |
-in[4]--| COUNTER4B |--out[4]-
        |___________|
             | |
-----load----/ |
-----reset-----/

Example:
--------
 in   | load | reset || out
 ---------------------------
 0101 | 0    | 0     || 0000
 1010 | 0    | 1     || 0001
 0101 | 1    | 0     || 0000
 1010 | 0    | 0     || 0101
 0110 | 1    | 1     || 0110
 1110 | 1    | 0     || 0000
 0000 | 0    | 0     || 1110
 0000 | 0    | 0     || 1111
 0000 | 0    | 0     || 0000
 0000 | 0    | 0     || 0001pptï¿½ADDER16Bsqï¿½~ï¿½ï¿½pppqï¿½~ï¿½@tÂº16-Bit Adder Specification
==========================

Description:
------------
The ADDER4B is a 16-bit bus version of the FULLADDER. It has therefore two 16-bit input busses and one 16-bit output bus while the carry in and out bits stay.
Check the appendix in the manual for binary notation of numbers and binary arithmetics.


Interface Specification:
------------------------
Inputs: carryIn, in1[16], in2[16];
Outputs: out[16], carryOut;pptï¿½DECODERsqï¿½~ï¿½ï¿½pt|Inputs: instr[16];
Outputs: cToM, loadA, loadD, loadM, op1, op2[2], opCode[4], jmpIfZ, constant[15];

Parts: MUXLOADM MUX, MUXLOADA MUX, MUXLOADD MUX,
       MUXJMPIFZ MUX,
       ADEMUX4WADDR DEMUX4W, BAND00 AND4B, BAND01 AND4B,
       BAND10 AND4B, BAND11 AND4B, COR4WA OR4W, COR4WM OR4W, COR4WD OR4W;

Wires: 
  1->ADEMUX4WADDR.in, instr[14:15]->ADEMUX4WADDR.sel,
  
  ADEMUX4WADDR.out1->BAND00.in1, 0000->BAND00.in2,
  ADEMUX4WADDR.out2->BAND01.in1, 0100->BAND01.in2,
  ADEMUX4WADDR.out3->BAND10.in1, 0010->BAND10.in2,
  ADEMUX4WADDR.out4->BAND11.in1, 0001->BAND11.in2,
  
  BAND00.out[3]->COR4WA.in[4], BAND00.out[2]->COR4WM.in[4],
  BAND01.out[3]->COR4WA.in[3], BAND01.out[2]->COR4WM.in[3],
  BAND10.out[3]->COR4WA.in[2], BAND10.out[2]->COR4WM.in[2],
  BAND11.out[3]->COR4WA.in[1], BAND11.out[2]->COR4WM.in[1],
  BAND00.out[1]->COR4WD.in[4], BAND01.out[1]->COR4WD.in[3],
  BAND10.out[1]->COR4WD.in[2], BAND11.out[1]->COR4WD.in[1],
  
  COR4WA.out->MUXLOADA.in1, 0->MUXLOADA.in2, instr[16]->MUXLOADA.sel,
  COR4WM.out->MUXLOADM.in1, 1->MUXLOADM.in2, instr[16]->MUXLOADM.sel,
  COR4WD.out->MUXLOADD.in1, instr[16]->MUXLOADD.sel,
  instr[6]->MUXJMPIFZ.in1, 0->MUXJMPIFZ.in2, instr[16]->MUXJMPIFZ.sel,
  
  instr[16]->cToM, MUXLOADA.out->loadA, MUXLOADM.out->loadM, MUXLOADD.out->loadD,
  instr[13]->op1, instr[11:12]->op2, instr[7:10]->opCode, 
  MUXJMPIFZ.out->jmpIfZ, instr[1:15]->constant
;







tï¿½dInputs: instr[16];
Outputs: cToM, loadA, loadD, loadM, op1, op2[2], opCode[4], jmpIfZ, constant[15];qï¿½~ï¿½CtÃ¯Instruction Decoder Specification
=================================

Description:
------------
The DECODER is used in the Microhard CPU for decoding instructions. There are two different kinds of instructions.

First, if instr[16] equals "1", then instr[1:15] have to be interpreted as a constant which has to be loaded into the memory register. In this case the "cToM" and "loadM" output has to be set to "1", while the "loadD", "loadA" and "jmpIfZ" outputs have to be "0". In addition the lower 15 bit of the instruction have to be written into "constant". 

Second, if instr[16] equals "0", then the decoder has to interpret the rest of the instruction in a more elaborate way:

bit:                         16 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1
instr[1:16]:                  0  d  d  a  b  b  o  o  o  o  j  c  c  c  c  c
                                 \__/  |  \__/  \________/  |  \___________/
instr[14:15] destination    ------/    |   |        |       |        |
instr[13]    operand1       -----------/   |        |       |        | 
instr[11:12] operand2       ---------------/        |       |        |
instr[7:10]  operation code ------------------------/       |        |
instr[6]     jump if zero   --------------------------------/        |
instr[1:5]   constant       -----------------------------------------/ 

In this case the CPU has to perform the operation specified by "operation code" with the operands decoded by "operand1" and "operand2".

The "operation code", the "operand1", the "operand2" and the "jump if zero" bits of the instruction can be directly transfered to the "opCode", "op1", "op2", "jmpIfZ" outputs of the decoder respectively.

As in the other case the lower 15 bit of the instruction have to be written into "constant". Note however, that in this case the CPU has to feed only the 5 lowest "constant" bits to the ALU when using the constant as an operand.

If "operand1" is "0" then the value of the address register is fed to the ALU as operand. Otherwise the "constant" represented by the bits instr[1:5] is fed as first operand.

The destination specifies where the result of the ALU operation has to be saved. While "op1" and "op2" are decoded by the CPU, the "destination" bits of the instruction have to be decoded by the DECODER in regards to the following decoding rules:

destination = 00 -> set loadA, loadM and loadD to 0
destination = 01 -> set loadA to 1 ; set loadM  and loadD to 0
destination = 10 -> set loadM to 1 ; set loadA  and loadD to 0
destination = 11 -> set loadD to 1 ; set loadA  and loadM to 0 

Interface Specification:
------------------------
Inputs: instr[16];
Outputs: cToM, loadA, loadD, loadM, op1, op2[2], opCode[4], jmpIfZ, constant[15];


Graphical Representation:
-------------------------
             _________
            |         |--cToM---------
            |         |--loadA----------
            |         |--loadD----------
            |         |--loadM----------
-instr[16]--| Decoder |--op1----------
            |         |--op2[2]-------
            |         |--opCode[4]----
            |         |--jmpIfZ-------
            |_________|--constant[15]-


Examples:
---------
 instr  || cToM | jmpIfZ | loadA | loadD | loadM | op1 | constant | op2 | opCode
 -------------------------------------------------------------------------------
 0x0000 || 0    | 0      | 0     | 0     | 0     | 0   | 0x0000   | 00  | 0000
 0x8000 || 1    | 0      | 0     | 0     | 1     | 0   | 0x0000   | 00  | 0000
 0xFFFF || 1    | 0      | 0     | 0     | 1     | 1   | 0x7FFF   | 11  | 1111
 0x7FFF || 0    | 1      | 0     | 1     | 0     | 1   | 0x7FFF   | 11  | 1111
 0x7C1F || 0    | 0      | 0     | 1     | 0     | 1   | 0x7C1F   | 11  | 0000
 0x7C0F || 0    | 0      | 0     | 1     | 0     | 1   | 0x7C0F   | 11  | 0000pptï¿½REGISTERsqï¿½~ï¿½ï¿½ptâ€˜//Logic: if load=0, DFF.out->DFF.in // load->NOT1, (NOT1,DFF1)->AND1,
//       if load=1, in->DFF.in      // (load, in)->AND2,
//                                  // (AND1, AND2)->OR1, OR1->DFF1
//                                  // DFF1->out 
// 1 NOT, 2 ANDs, 1 OR, 1 DFF

Inputs: in, load;
Outputs: out;

// 1. specify the components you want to use here
Parts: NOT1A NOT, AND2A AND, AND2B AND, OR3A OR, DFF4A DFF;

// 2. wire them up
Wires: 
  load->NOT1A.in,
  
  DFF4A.out->AND2A.in1, NOT1A.out->AND2A.in2, 
  in->AND2B.in1, load->AND2B.in2,
  
  AND2A.out->OR3A.in1, AND2B.out->OR3A.in2,
  
  OR3A.out->DFF4A.in,
  
  DFF4A.out->out
;














tï¿½Inputs: in, load;
Outputs: out;qï¿½~ï¿½HtÃ—1-Bit Register Specification
============================

Description:
------------
Like the DFF element the REGISTER element has an internal state, an input and an output. The internal state of the REGISTER however is only set to the value of the input in case the input load flag is 1.
Check the DFF specification and the manual for sequential logic.

Interface Specification:
------------------------
Inputs: in, load;
Outputs: out;


Graphical Representation:
-------------------------
      _____
     |     |
-in--| REG |--out-
     |_____|
        |
--load--/


Example:
--------
 in  | load || out
 -----------------
 0   | 0    || 0
 1   | 0    || 0
 1   | 1    || 0
 0   | 0    || 1
 0   | 1    || 1
 0   | 0    || 0pptï¿½ADDER4Bsqï¿½~ï¿½ï¿½pt^Inputs: in1[4], in2[4], carryIn;
Outputs: out[4], carryOut;

// 1. specify the components you want to use here
Parts: FA1A FULLADDER, FA2A FULLADDER, FA3A FULLADDER, FA4A FULLADDER;

// 2. wire them up
Wires: 
  in1[1]->FA1A.in1, in2[1]->FA1A.in2, carryIn->FA1A.carryIn,
  FA1A.out->out[1],
  
  in1[2]->FA2A.in1, in2[2]->FA2A.in2, FA1A.carryOut->FA2A.carryIn,
  FA2A.out->out[2],
  
  in1[3]->FA3A.in1, in2[3]->FA3A.in2, FA2A.carryOut->FA3A.carryIn,
  FA3A.out->out[3],
  
  in1[4]->FA4A.in1, in2[4]->FA4A.in2, FA3A.carryOut->FA4A.carryIn,
  FA4A.out->out[4], FA4A.carryOut->carryOut
;



















tï¿½;Inputs: in1[4], in2[4], carryIn;
Outputs: out[4], carryOut;qï¿½~ï¿½MtÃ»4-Bit Adder Specification
=========================

Description:
------------
The ADDER4B is a 4-bit bus version of the FULLADDER. It has therefore two 4-bit input busses and one 4-bit output bus while the carry in and out bits are kept.
Check the appendix in the manual for binary notation of numbers and binary arithmetics.


Interface Specification:
------------------------
Inputs: carryIn, in1[4], in2[4];
Outputs: out[4], carryOut;


Graphical Representation:
-------------------------
-carryIn----\
          __|____
-in1[4]--|       |
         | ADD4B |--out[4]-
-in2[4]--|_______|
              |
              \--carryOut--

Examples:
---------
 carryIn | in1  | in2  || out  | carryOut
 ----------------------------------------
 0       | 0000 | 0000 || 0000 | 0
 0       | 0101 | 0101 || 1010 | 0
 0       | 1010 | 1010 || 0100 | 1
 0       | 1111 | 1111 || 1110 | 1
 1       | 0000 | 0000 || 0001 | 0
 1       | 0101 | 0101 || 1011 | 0
 1       | 1010 | 1010 || 0101 | 1
 1       | 1111 | 1111 || 1111 | 1pptï¿½ORsqï¿½~ï¿½ï¿½ptâ€¢Inputs: in1, in2;
Outputs: out;

// Logic: in1 -> NOT -> AND -> NOT -> OUT
//        in2 -> NOT _/

// 1. specify the components you want to use here
// Parts: 
//  AND AND, 
//  NOT1 NOT,
//  NOT2 NOT,
//  NOT3 NOT
//;

// 2. wire them up
//Wires: 
//  in1 -> NOT1.in,
//  in2 -> NOT2.in,
//  NOT1.out -> AND.in1,
//  NOT2.out -> AND.in2,
//  AND.out -> NOT3.in,
//  NOT3.out -> out
//;

// Logic: (in1, in1) -> NAND1 -> NAND3 \_ OUT
//        (in2, in2) -> NAND2 -> NAND3 /

Parts: NAND1 NAND, NAND2 NAND, NAND3 NAND;

Wires: 
  in1->NAND1.in1,in1->NAND1.in2,NAND1.out->NAND3.in1,
  in2->NAND2.in1,in2->NAND2.in2,NAND2.out->NAND3.in2,
  NAND3.out->out
;





tï¿½Inputs: in1, in2;
Outputs: out;qï¿½~ï¿½RtÃ²Or Specification
================

Description:
------------
The OR gate has two inputs and one output. If at least one input is 1, the output is 1. Otherwise the output is 0.


Interface Specification:
------------------------
Inputs: in1, in2;
Outputs: out;


Graphical Representation:
-------------------------
       ____
-in1--|    |
      | OR |--out-
-in2--|____|


Truth Table:
------------
 in1 | in2 || out
 ----------------
 0   | 0   || 0
 0   | 1   || 1
 1   | 0   || 1
 1   | 1   || 1pptï¿½OR4Wsqï¿½~ï¿½ï¿½ptEInputs: in[4];
Outputs: out;

// 1. specify the components you want to use here
Parts: 
  OR12 OR,
  OR34 OR,
  OR56 OR
;

// 2. wire them up
Wires: 
  in[1] -> OR12.in1,
  in[2] -> OR12.in2,
  in[3] -> OR34.in1,
  in[4] -> OR34.in2,

  OR12.out -> OR56.in1,
  OR34.out -> OR56.in2,
  
  OR56.out -> out
  
;
















tï¿½Inputs: in[4];
Outputs: out;qï¿½~ï¿½Wt4-Way Or Specification
======================

Description:
------------
The OR4W element is a bus version of the OR gate. If at least one of the bits in the bus is 1, the output is 1. Otherwise the output is 0.


Interface Specification:
------------------------
Inputs: in[4];
Outputs: out;


Graphical Representation:
-------------------------
         ______
        |      |
-in[4]--| OR4W |--out-
        |______|


Examples:
---------
 in   || out
 ------------
 0000 || 0
 1111 || 1
 0101 || 1
 1010 || 1
 0110 || 1
 1001 || 1pptï¿½
RAM64KW16Bsqï¿½~ï¿½ï¿½pppqï¿½~ï¿½\tÃ€64k-Register 16-Bit RAM Specification
=====================================

Description:
------------
The RAM64KW16B is a random access memory with 65536 addressable registers and 16-bit bus width. In addition to a regular register, the RAM64KW16B can save and retrieve 65536 different values, which can be addressed via the address input bus.

Interface Specification:
------------------------
Inputs: in[16], load, address[16];
Outputs: out[16];pptï¿½NAND4Bsqï¿½~ï¿½ï¿½pppqï¿½~ï¿½_t&4-Bit Nand Specification
========================

Description:
------------
The NAND4B element is a bus version of the NAND gate. It applies the Nand-operation to each pair of bits from both inputs.  


Interface Specification:
------------------------
Inputs: in1[4], in2[4];
Outputs: out[4];pptï¿½	BRIEFING7sqï¿½~ï¿½ï¿½ï¿½tÅ’Amazing!

I knew from the beginning we could count on you! We wouldn't have come this far without you, but not all is over yet. While there is no doubt you created a great product, people simply don't know yet. I got everything set up so we can start manufacturing ASAP and our marketing and sales department are spinning.

It will take a while for us to get the Microhard CPU out into the wild and there is not much to do for you right now.

Why don't you take a vacation and check back in a few months. You deserved it! I will make sure to come up with some new ideas in the meantime.

Looking forward to talk you then,
Will

(PS: TO BE CONTINUED...)ppqï¿½~ï¿½bppptï¿½	BRIEFING6sqï¿½~ï¿½ï¿½ï¿½tÃ—We have come a long way!

We finally got all elements necessary to build our Microhard CPU! Our CPU consists (roughly speaking) of an ALU and a couple of registers. All that is left is to wire those things up, which is easier said then done.

Building the CPU is a two step process... first you should design the decoder and second the CPU itself. However to be able to understand each single element, you have to understand both and how they act together. Start out by studying both specs provided.

This is the final step we need to complete in order to to take action on the market! Everything stands and falls with this design! We all put our hopes and dreams in your hands! This could change the world! 

No pressure,
Willppqï¿½~ï¿½eppptï¿½	BRIEFING5sqï¿½~ï¿½ï¿½ï¿½t(The best CPU in the world isn't worth a whole lot, if you can't save the program that drives it or the results it produces.

Something that all the hardware elements you designed so far have in common is the absence of memory. We need to change this. That is why I got a business associate to source some sweet D-Flip-Flops!

When designing sequential elements make sure you consider the timing aspect... check out the chapter on sequential logic in the manual and have a look at the spec sheet for the D-Flip-Flop under the "Completed/" folder.

Will ppqï¿½~ï¿½hppptï¿½	BRIEFING4sqï¿½~ï¿½ï¿½ï¿½tÂ¤Great stuff! We're getting closer to blowing up the CPU market place step by step, design by design...

As you might know the actual computations a CPU performs are done by its ALU (algorithmic logic unit) and the exciting thing is: we basically got everything together we need to build our own ALU. You just need to wire it up.

At the risk of repeating myself: Make sure you draw out your design on paper first!

Will ppqï¿½~ï¿½kppptï¿½
COUNTER16Bsqï¿½~ï¿½ï¿½pppqï¿½~ï¿½ntÂ­16-Bit Counter Specification
============================

Description:
------------
The COUNTER16B is similiar to an REG16B, with two differences.
First: For every clock cycle the load flag is 0, the internal value increments.
Second: It has an additional reset input flag. If it is 1 the internal value has to be set to "0x0000".

Interface Specification:
------------------------
Inputs: in[16], load, reset;
Outputs: out[16];pptï¿½	BRIEFING2sqï¿½~ï¿½ï¿½ï¿½tÂ³Great news for you today!

I know that doing bus versions of finished designs can be tedious and we don't want to waste your mind on monkey work... gladly I was able to hire an intern, who will help you out with that!

Ted is a novice and therefore don't expect him to come up with any original designs, but he will assist you in creating any bus versions similar to ones you already created.

Ted gets the work, you get the fun!
Will ppqï¿½~ï¿½qppptï¿½	BRIEFING1sqï¿½~ï¿½ï¿½ï¿½tË†It's great to see you got the hang of things around here!

The elements you built so far work great, but we need to develop bus versions of those. Designing those should be a trivial task as you can reuse the elements you developed so far... however make sure you understand the bus syntax of the design editor first!

Check the part in the manual on bus syntax.

Keep up the great work,
Willppqï¿½~ï¿½tppptï¿½	BRIEFING0sqï¿½~ï¿½ï¿½ï¿½t(Welcome aboard!

One man once said: Giants are not what we think they are. The same qualities that appear to give them strength are often the sources of great weakness.

We at Microhard firmly believe that the modern CPUs available in the market place are far more complex than what is good for them. By having complex instruction sets and downward compatibility the giants of the tech industry trade legacy for efficiency. These circumstances provide us at Microhard with an opportunity to disrupt the tech industry by providing a low-cost, high-efficiency CPU alternative. I am glad that I could win you over as an hardware engineer for our endeavour.

Your job will be to design various hardware elements we need in order to build our CPU. You will be provided with specifications and verification tests for the elements you have to design. If you ever feel lost or overwhelmed, don't panic... make sure you remember these three tips:

1. If you don't know what to do: Read the manual and specifications!
2. When creating your design: Draw it out on a piece of paper! No one ever
   created something great just by looking at his screen...
3. If something is wrong with your design: Inspect the error messages and failed
   tests closely to find out where the problem is.

Keep these in mind... they will come in handy sooner rather than later!

Your first task will be to develop a NOT gate. You can find the task under the "Tasks/" folder in the explorer to your left. You maybe want to check out the manual first however...

I'm looking forward to working together,
Willppqï¿½~ï¿½wppptï¿½ALU4Bsqï¿½~ï¿½ï¿½ptPInputs: in1[4], in2[4], opCode[4];
Outputs: out[4], negative, zero;

// 1. specify the components you want to use here
Parts: ANOT4B1 NOT4B, AMUX4B1 MUX4B, BNOT4B1 NOT4B, BMUX4B1 MUX4B, 
       CADD4B1 ADDER4B, CNAND4B1 NAND4B, DMUX4B1 MUX4B, ENOT4B1 NOT4B, 
       EMUX4B1 MUX4B, FNOT4B1 NOT4B, FAND1 AND, FAND2 AND, FAND3 AND
;
// 2. wire them up
Wires: 
  in1->ANOT4B1.in, in1->AMUX4B1.in1, ANOT4B1.out->AMUX4B1.in2, 
  opCode[4]->AMUX4B1.sel,
  
  in2->BNOT4B1.in, in2->BMUX4B1.in1, BNOT4B1.out->BMUX4B1.in2,
  opCode[3]->BMUX4B1.sel,
  
  AMUX4B1.out->CADD4B1.in1, BMUX4B1.out->CADD4B1.in2,
  AMUX4B1.out->CNAND4B1.in1, BMUX4B1.out->CNAND4B1.in2,
  
  CADD4B1.out->DMUX4B1.in1, CNAND4B1.out->DMUX4B1.in2, opCode[2]->DMUX4B1.sel,
  
  DMUX4B1.out->ENOT4B1.in, DMUX4B1.out->EMUX4B1.in1, ENOT4B1.out->EMUX4B1.in2,
  opCode[1]->EMUX4B1.sel, 
  
  EMUX4B1.out->out, EMUX4B1.out[4]->negative, EMUX4B1.out->FNOT4B1.in,
  FNOT4B1.out[4]->FAND1.in1, FNOT4B1.out[3]->FAND1.in2, 
  FNOT4B1.out[2]->FAND2.in1, FNOT4B1.out[1]->FAND2.in2,
  FAND1.out->FAND3.in1, FAND2.out->FAND3.in2, FAND3.out->zero

;









tï¿½CInputs: in1[4], in2[4], opCode[4];
Outputs: out[4], negative, zero;qï¿½~ï¿½ztVMicrohard 4-Bit Algorithmic Logic Unit Specification
====================================================

Description:
------------
The ALU4B element has two data bus inputs and an operation code bus input. The element can perform 16 different operations on the data inputs and writes the result to the data bus output. The operation to perform is determined by the value of the operation code bus. Additionally the ALU has flags to indicate whether the final result is zero or negative
Each bit in the operation code bus has a dedicated function:
opCode[4] -> if 1: negate in1 bitwise
opCode[3] -> if 1: negate in2 bitwise
opCode[2] -> if 0: out = (in1 ADD in2); if 1: out = (in1 NAND in2);
opCode[1] -> if 1: negate out bitwise
Through the negation of the inputs and outputs in combination with the application of the add- and nand-functions, a lot of results can be achieved as can be seen in the examples.


Interface Specification:
------------------------
Inputs: in1[4], in2[4], opCode[4];
Outputs: out[4], negative, zero;


Graphical Representation:
-------------------------
          _____
-in1[4]--|     |--out[4]---
         | ALU |--zero-----
-in2[4]--|_____|--negative-
            |
-opCode[4]--/


Examples:
---------
 opCode | in1  | in2  || out  | zero | negative
 ----------------------------------------------
 0000   | 0011 | 0101 || 1000 | 0    | 1        // in1 + in2
 0000   | 0001 | 1111 || 0000 | 1    | 0        // overflow
 0101   | 0011 | 0101 || 0010 | 0    | 0        // in2 - in1
 1001   | 0011 | 0101 || 1110 | 0    | 1        // in1 - in2
 0010   | 0011 | 0101 || 1110 | 0    | 1        // in1 nand in2
 0011   | 0011 | 0101 || 0001 | 0    | 0        // in1 and in2
 1110   | 0011 | 0101 || 0111 | 0    | 0        // in1 or in2
 0101   | 0011 | 0000 || 1101 | 0    | 1        // -in1
 0001   | 1100 | 0000 || 0011 | 0    | 0        // not in1
pptï¿½NOT16Bsqï¿½~ï¿½ï¿½pppqï¿½~ï¿½t16-Bit Not Specification
========================

Description:
------------
The NOT16B element is a bus version of the NOT gate. It applies the Not-operation to every bit in the bus.  


Interface Specification:
------------------------
Inputs: in[16];
Outputs: out[16];pptï¿½OR16Wsqï¿½~ï¿½ï¿½pppqï¿½~ï¿½â€št(16-Way Or Specification
=======================

Description:
------------
The OR16W element is a bus version of the OR gate. If at least one of the bits in the bus is 1, the output is 1. Otherwise the output is 0.


Interface Specification:
------------------------
Inputs: in[16];
Outputs: out;pptï¿½NOT4Bsqï¿½~ï¿½ï¿½pt`Inputs: in[4];
Outputs: out[4];

// 1. specify the components you want to use here
Parts:
  NOT1 NOT,
  NOT2 NOT,
  NOT3 NOT,
  NOT4 NOT
;

// 2. wire them up
Wires:
  in[1] -> NOT1.in,
  NOT1.out -> out[1],
  in[2] -> NOT2.in,
  NOT2.out -> out[2],
  in[3] -> NOT3.in,
  NOT3.out -> out[3],
  in[4] -> NOT4.in,
  NOT4.out -> out[4]
;

















tï¿½Inputs: in[4];
Outputs: out[4];qï¿½~ï¿½â€¦t4-Bit Not Specification
=======================

Description:
------------
The NOT4B element is a bus version of the NOT gate. It applies the Not-operation to every bit in the bus.  


Interface Specification:
------------------------
Inputs: in[4];
Outputs: out[4];


Graphical Representation:
-------------------------
         _______
        |       |
-in[4]--| NOT4B |--out[4]-
        |_______|


Examples:
---------
 in   || out
 ------------
 0000 || 1111
 1111 || 0000
 0101 || 1010
 1010 || 0101
 0110 || 1001
 1001 || 0110pptï¿½MUXsqï¿½~ï¿½ï¿½ptï¿½Inputs:in1,in2,sel; 
Outputs:out;
Parts: NOT1 NOT, AND1 AND, AND2 AND, OR1 OR; 
Wires:
  sel->NOT1.in, NOT1.out->AND1.in1, in1->AND1.in2,
  sel->AND2.in1, in2->AND2.in2,
  AND1.out->OR1.in1, AND2.out->OR1.in2, OR1.out->out
;































tï¿½$Inputs: in1, in2, sel;
Outputs: out;qï¿½~ï¿½Å tMultiplexer Specification
=========================

Description:
------------
The MUX element has two data inputs, one select input and one data output. If the select input is 0, the data from the first input is transfered to the output. Otherwise the data from the second input is transfered to the output. 


Interface Specification:
------------------------
Inputs: in1, in2, sel;
Outputs: out;


Graphical Representation:
-------------------------
       ____
-in1--|    \
      | MUX |--out-
-in2--|____/
        |
-sel----/


Truth Table:
------------
 sel | in1 | in2 || out
 -----------------------
 0   | 0   | 0   || 0
 0   | 0   | 1   || 0
 0   | 1   | 0   || 1
 0   | 1   | 1   || 1
 1   | 0   | 0   || 0
 1   | 0   | 1   || 1
 1   | 1   | 0   || 0
 1   | 1   | 1   || 1

pptï¿½NOTsqï¿½~ï¿½ï¿½ptuInputs: in;
Outputs: out;

// 1. specify the components you want to use here
//Parts:
//  NAND NAND
//;

// 2. wire them up
//Wires:
//  in -> NAND.in1, 1 -> NAND.in2, NAND.out -> out  
//;
// press CTRL + ENTER to start verification process

// Logic: (in,in) -> NAND -> out
Parts: NAND NAND;
Wires:
  in -> NAND.in1, in -> NAND.in2, NAND.out -> out
;




















tï¿½Inputs: in;
Outputs: out;qï¿½~ï¿½Ât5Not Specification
=================

Description:
------------
The NOT gate has an input and an output. If the input is 1, the output is 0 and vice versa. Therefore the NOT gate simply negates its input.
Like any other element NOT gates can be build by using NAND gates. Check out the NAND specification.


Interface Specification:
------------------------
Inputs: in;
Outputs: out;


Graphical Representation:
-------------------------
      _____
     |     |
-in--| NOT |--out-
     |_____|


Truth Table:
------------
 in  || out
 ----------
 0   || 1
 1   || 0pptï¿½ALU16Bsqï¿½~ï¿½ï¿½pppqï¿½~ï¿½â€tMicrohard 16-Bit Algorithmic Logic Unit Specification
=====================================================

Description:
------------
The ALU16B element has two data bus inputs and an operation code bus input. The element can perform 16 different operations on the data inputs and writes the result to the data bus output. The operation to perform is determined by the value of the operation code bus. Additionally the ALU has flags to indicate whether the final result is zero or negative
Each bit in the operation code bus has a dedicated function:
opCode[4] -> if 1: negate in1 bitwise
opCode[3] -> if 1: negate in2 bitwise
opCode[2] -> if 0: out = (in1 ADD in2); if 1: out = (in1 NAND in2);
opCode[1] -> if 1: negate out bitwise
Through the negation of the inputs and outputs in combination with the application of the add- and nand-functions, a lot of results can be achieved as can be seen in the examples.


Interface Specification:
------------------------
Inputs: in1[16], in2[16], opCode[4];
Outputs: out[16], negative, zero;pptï¿½AND16Bsqï¿½~ï¿½ï¿½pppqï¿½~ï¿½â€”t'16-Bit And Specification
========================

Description:
------------
The AND16B element is a bus version of the AND gate. It applies the And-operation to each pair of bits from both inputs.  


Interface Specification:
------------------------
Inputs: in1[16], in2[16];
Outputs: out[16];pptï¿½XOR4Bsqï¿½~ï¿½ï¿½pppqï¿½~ï¿½Å¡tÂ¾4-Bit X-Or Specification
========================

Description:
------------
The XOR4B element is a bus version of the XOR gate. It applies the XOR-operation to each pair of bits from both inputs.  


Interface Specification:
------------------------
Inputs: in1[4], in2[4];
Outputs: out[4];


Graphical Representation:
-------------------------
          _______
-in1[4]--|       |
         | XOR4B |--out[4]-
-in2[4]--|_______|


Examples:
---------
 in1  | in2  || out
 -------------------
 0000 | 0000 || 0000
 0000 | 0101 || 0101
 0000 | 1010 || 1010
 0000 | 1111 || 1111
 0101 | 0101 || 1111
 0101 | 1010 || 0000
 0101 | 1111 || 1010
 1010 | 1010 || 0000
 1010 | 1111 || 0101
 1111 | 1111 || 0000pptï¿½MUX16Bsqï¿½~ï¿½ï¿½pppqï¿½~ï¿½Ât`16-Bit Multiplexer Specification
================================

Description:
------------
The MUX16B element is a bus version of the MUX gate. It transfers the complete data of the input busses to the output bus, but otherwise behaves identically. 


Interface Specification:
------------------------
Inputs: in1[16], in2[16], sel;
Outputs: out[16];pptï¿½ANDsqï¿½~ï¿½ï¿½ptÃ˜Inputs: in1, in2;
Outputs: out;

// Logic: IN -> NAND -> NOT -> OUT

// 1. specify the components you want to use here
//Parts: NAND NAND, NOT NOT;

// 2. wire them up
//Wires:
//  in1 -> NAND.in1,
//  in2 -> NAND.in2,
//  NAND.out -> NOT.in,
//  NOT.out -> out  
//;


// Logic: IN -> NAND -> NAND -> OUT
Parts:
  NAND1 NAND,
  NAND2 NAND
;

Wires:
  in1 -> NAND1.in1,
  in2 -> NAND1.in2,
  NAND1.out -> NAND2.in1,
  NAND1.out -> NAND2.in2,
  NAND2.out -> out
;









tï¿½Inputs: in1, in2;
Outputs: out;qï¿½~ï¿½Â t*And Specification
=================

Description:
------------
The AND gate has two inputs and one output. If both inputs are 1, the output is 1. Otherwise the output is 0. 
The AND gate is the negated version of the NAND gate.


Interface Specification:
------------------------
Inputs: in1, in2;
Outputs: out;


Graphical Representation:
-------------------------
       _____
-in1--|     |
      | AND |--out-
-in2--|_____|


Truth Table:
------------
 in1 | in2 || out
 ----------------
 0   | 0   || 0
 0   | 1   || 0
 1   | 0   || 0
 1   | 1   || 1pptï¿½	HALFADDERsqï¿½~ï¿½ï¿½ptInputs: in1, in2;
Outputs: out, carry;

// 1. specify the components you want to use here
Parts: XOR1A XOR, AND1 AND;

// 2. wire them up
Wires: 
  in1->XOR1A.in1, in2->XOR1A.in2, XOR1A.out->out,
  in1->AND1.in1,  in2->AND1.in2,  AND1.out->carry 
;




























tï¿½&Inputs: in1, in2;
Outputs: out, carry;qï¿½~ï¿½Â¥tÂ Half Adder Specification
========================

Description:
------------
The HALFADDER takes two bits as inputs and adds them up. The sum is given as output as well as a carry bit.
Check the appendix in the manual for binary notation of numbers and binary arithmetics.


Interface Specification:
------------------------
Inputs: in1, in2;
Outputs: out, carry;


Graphical Representation:
-------------------------
       ____
-in1--|    |
      | HA |--out-
-in2--|____|
         |
         \--carry-


Truth Table:
------------
 in1 | in2 || out | carry
 ------------------------
 0   | 0   || 0   | 0
 0   | 1   || 1   | 0
 1   | 0   || 1   | 0
 1   | 1   || 0   | 1pptï¿½DEMUX4Wsqï¿½~ï¿½ï¿½ptÃ¹// Logic: Convert selector to TRUE for corresponding position. (1, in)->AND->out

Inputs: in, sel[2];
Outputs: out1, out2, out3, out4;

// 3 NOTs, 4 AND4Bs
Parts: NOT1A NOT, NOT1B NOT, AND4B2A AND4B, AND4B3A AND4B;

// NOT1A = (0)0  [4,3]
// NOT2A = 0(0)  [2,1]
// sel[2] = (1)0 [4,3]
// sel[1] = 0(1) [2,1]

Wires: 
  sel[2]->NOT1A.in, sel[1]->NOT1B.in,
  
  NOT1A.out->AND4B2A.in1[4], NOT1B.out->AND4B2A.in2[4], //00
  NOT1A.out->AND4B2A.in1[3], sel[1]->AND4B2A.in2[3],    //01
  sel[2]->AND4B2A.in1[2], NOT1B.out->AND4B2A.in2[2],    //10
  sel[2]->AND4B2A.in1[1], sel[1]->AND4B2A.in2[1],       //11
  
  AND4B2A.out->AND4B3A.in1, in->AND4B3A.in2,
  
  AND4B3A.out[4]->out1,
  AND4B3A.out[3]->out2,
  AND4B3A.out[2]->out3,
  AND4B3A.out[1]->out4
;











tï¿½4Inputs: in, sel[2];
Outputs: out1, out2, out3, out4;qï¿½~ï¿½Âªtâ€˜4-Way Demultiplexer Specification
=================================

Description:
------------
The DEMUX4W element has one data input, a 2-bit select bus input and four outputs. The value of the select input bus determines the output which the input data is transfered to. The value of all other outputs is zero.
For example: If the select bus has the value "10", the data is transfered to the third output. Check the appendix in the manual for binary notation. 


Interface Specification:
------------------------
Inputs: in, sel[2];
Outputs: out1, out2, out3, out4;


Graphical Representation:
-------------------------
        _______
       /       |--out1-
      /        |--out2-
-in--| DEMUX4W |
      \        |--out3-
       \_______|--out4-
           |
--sel[2]---/

Truth Table:
------------
 sel | in || out1 | out2 | out3 | out4
 -------------------------------------
 00  | 0  || 0    | 0    | 0    | 0
 00  | 1  || 1    | 0    | 0    | 0
 01  | 0  || 0    | 0    | 0    | 0
 01  | 1  || 0    | 1    | 0    | 0
 10  | 0  || 0    | 0    | 0    | 0
 10  | 1  || 0    | 0    | 1    | 0
 11  | 0  || 0    | 0    | 0    | 0
 11  | 1  || 0    | 0    | 0    | 1pptï¿½XORsqï¿½~ï¿½ï¿½ptdInputs: in1, in2;
Outputs: out;

// 1. specify the components you want to use here
Parts:
  NAND NAND,
  OR OR,
  AND AND
;

// 2. wire them up
Wires: 
  // NAND
  in1 -> NAND.in1,
  in2 -> NAND.in2,
  // OR
  in1 -> OR.in1,
  in2 -> OR.in2,
  // NAND & OR OUTS -> AND
  NAND.out -> AND.in1,
  OR.out -> AND.in2,
  // out
  AND.out -> out
;















tï¿½Inputs: in1, in2;
Outputs: out;qï¿½~ï¿½Â¯tX-Or Specification
==================

Description:
------------
The XOR gate (short for Exclusive-Or) has two inputs and one output. If _exactly_ one input is 1, the output is 1. Otherwise the output is 0.


Interface Specification:
------------------------
Inputs: in1, in2;
Outputs: out;


Graphical Representation:
-------------------------
       _____
-in1--|     |
      | XOR |--out-
-in2--|_____|


Truth Table:
------------
 in1 | in2 || out
 ----------------
 0   | 0   || 0
 0   | 1   || 1
 1   | 0   || 1
 1   | 1   || 0pptï¿½AND4Bsqï¿½~ï¿½ï¿½ptÃ‡Inputs: in1[4], in2[4];
Outputs: out[4];

// 1. specify the components you want to use here
Parts:
  AND1 AND,
  AND2 AND,
  AND3 AND,
  AND4 AND
;

// 2. wire them up
Wires:
  in1[1] -> AND1.in1,
  in2[1] -> AND1.in2,
  in1[2] -> AND2.in1,
  in2[2] -> AND2.in2,
  in1[3] -> AND3.in1,
  in2[3] -> AND3.in2,
  in1[4] -> AND4.in1,
  in2[4] -> AND4.in2,
  
  AND1.out -> out[1],
  AND2.out -> out[2],
  AND3.out -> out[3],
  AND4.out -> out[4]
;












tï¿½(Inputs: in1[4], in2[4];
Outputs: out[4];qï¿½~ï¿½Â´tÂ¼4-Bit And Specification
=======================

Description:
------------
The AND4B element is a bus version of the AND gate. It applies the And-operation to each pair of bits from both inputs.  


Interface Specification:
------------------------
Inputs: in1[4], in2[4];
Outputs: out[4];


Graphical Representation:
-------------------------
          _______
-in1[4]--|       |
         | AND4B |--out[4]-
-in2[4]--|_______|


Examples:
---------
 in1  | in2  || out
 -------------------
 0000 | 0000 || 0000
 0000 | 0101 || 0000
 0000 | 1010 || 0000
 0000 | 1111 || 0000
 0101 | 0101 || 0101
 0101 | 1010 || 0000
 0101 | 1111 || 0101
 1010 | 1010 || 1010
 1010 | 1111 || 1010
 1111 | 1111 || 1111ppxsrï¿½java.util.ArrayListxÂÃ’â„¢Ã‡aÂï¿½Iï¿½sizexpï¿½ï¿½ï¿½wï¿½ï¿½ï¿½srï¿½model.Folder9WÃ»BBNGï¿½Zï¿½	collapsedLï¿½filestï¿½Ljava/util/List;Lï¿½nameqï¿½~ï¿½xpï¿½sqï¿½~ï¿½Â¹ï¿½ï¿½ï¿½wï¿½ï¿½ï¿½sqï¿½~ï¿½Â»sqï¿½~ï¿½Â¹ï¿½ï¿½ï¿½wï¿½ï¿½ï¿½qï¿½~ï¿½xqï¿½~ï¿½uqï¿½~ï¿½rqï¿½~ï¿½iqï¿½~ï¿½lqï¿½~ï¿½fqï¿½~ï¿½cxtï¿½
Briefings\sqï¿½~ï¿½Â»sqï¿½~ï¿½Â¹ï¿½ï¿½ï¿½wï¿½ï¿½ï¿½sqï¿½~ï¿½ï¿½ï¿½toIntroduction
============

This manual will tell you everything you need to know to start creating hardware elements. This chapter will give you a rough overview of what you have to do. The other chapters will give you detailed information on specific topics. Also the manual contains a tutorial you may find helpful.

In your job as an hardware engineer your task is to create designs for hardware elements. You will get specifications for the hardware elements you have to design and you will be provided with verification tests to prove that your design works correctly.

Be aware, that in the "Explorer" window you will find a "Tasks" folder, which contains all the designs you have to finish and a "Completed" folder, with parts you either have completed yourself or you can simply use for your own designs.

A specification always contains the interface specification, a graphical representation and behavioral description of the element you have to design.
- The interface specification is a list of inputs and outputs, each identified
  by a separate id
- The graphical representation helps you to visualize the element look, but
  doesn't contain any additional information
- The behavioral description contains a textual description of what the device
  is supposed to do. It also gives you a complete or incomplete list of
  examples of what output values the device is supposed to generate for a
  given set of inputs 

After you created your design you have to verify its correctness through the simulator integrated into the Microhard Development Environment. The verification process has following steps:
- Check compliance of the design with the interface specification
- Check compliance of the design with the syntax specification
- Check if design passes all verification tests

If the verification fails on the first two points, you will be given a corresponding error message. If one or more tests fail, you will be given a list of all tests and their results.

If you have problems creating a design try following approach:

1.  Read the element specification carefully.
1a. If it contains references to other elements or the manual, read the
    corresponding element specifications or manual chapters.
2.  Draw out a design on a piece of paper. You are allowed to use any already
    completed hardware elements as part of your new design.
3.  Once you think your design is correct, start writing it down in the
    "Design"-tab of the workspace according to the syntax specification.
4.  Press CTRL+ENTER to start the verification process
4a. In case you get an error message, closely inspect the error message and go
    back to step 3 to fix the problem in the design.
4b. In case one or more tests fail, pick a failed test and try to understand
    what happens if you apply its input values to your design and why your 
    design's output values differ from the expected output values in the test.
    Go back to step 2 to fix that issue.
5.  If you made your way to this step: Congratulations! You successfully
    created the design for a piece of hardware.

The tutorial contained in this manual should prepare you to complete the first actual tasks.pptï¿½INTRODUCTIONpppsqï¿½~ï¿½Â»sqï¿½~ï¿½Â¹ï¿½ï¿½ï¿½wï¿½ï¿½ï¿½sqï¿½~ï¿½ï¿½ï¿½ptâ€¡// The design always starts with the interface which 
// is always exactly what the specification specifies
Inputs: in1, in2;
Outputs: out1, out2;

// btw... lines starting with "//" are comments and
// are not considered in the verification process

// the specification says, that the outputs have to
// have the same values as the inputs, but switched...
// this can be done by connecting in1 to out2 and
// connecting in2 to out1.

// if you drew this... it would look something like this:
//
//       +-------+           
//  -in1-|--\ /--|--out1-
//       |   X   |    
//  -in2-|--/ \--|--out2-
//       +-------+     

Wires:
// however you have to tell the simulator what to do
// accordingly to the syntax specification...
// this means you would write:
  in1 -> out2,
  in2 -> out1
;

// So the syntax for wiring is basically:
// [start_pin] -> [end_pin]
// you can specify as many wires as you like, but you
// have to separate them by commas
// after the last wire you have to put a semicolon

// try pressing CTRL+ENTER... this will tell you that
// this design passed verification

// you can mess with the design to make the verification fail
tï¿½&Inputs: in1, in2;
Outputs: out1, out2;tï¿½	TUTORIAL1thTutorial 1 - Specification
==========================

Description:
------------
This tutorial is meant to get you started with the Microhard Development Environment. This tutorial has the exact same structure a normal hardware element has, except that it basically provides you with a working solution.

What you are currently reading is the specification of the TUT1 hardware element. In this tutorial we will create a design for it which has the following behavior:

"The TUT1 element has two inputs and two outputs. The first output should output whatever value the second input has and the second output should output the value of the first input."

Make sure you read the rest of this specification and then head over to the "Design"-tab.  

Interface Specification:
------------------------
Inputs: in1, in2;
Outputs: out1, out2;


Graphical Representation:
-------------------------
       ______
-in1--|      |--out1-
      | TUT1 |
-in2--|______|--out2-


Example:
--------
 in1 | in2 || out1 | out2
 -------------------------
 0   | 0    || 0   | 0
 0   | 1    || 1   | 0
 1   | 0    || 0   | 1
 1   | 1    || 1   | 1ptï¿½â€“Tests:
  0->in1, 0->in2, out1->0, out2->0;
  0->in1, 1->in2, out1->1, out2->0;
  1->in1, 0->in2, out1->0, out2->1;
  1->in1, 1->in2, out1->1, out2->1;sqï¿½~ï¿½ï¿½ï¿½ptÃ±// The interface spec of the NAND Gate:
Inputs: in1, in2;
Outputs: out;

// Now to build a NAND gate based on a NAND gate is kind
// of pointless in the bigger scheme of things, but here
// is how it would look like:
//
//       +----------+
//       |  ______  |          
//  -in1-|-|      | |
//       | | NAND |-|--out-
//  -in2-|-|______| |
//       +----------+

// Now between the interface and the "Wires" section there
// is a "Parts" section where you need to specify which
// parts are used within your design
Parts:
  myNand NAND
;
// so the syntax here is:
// [id] [part_type]
// you can choose an id, but the part type has to be in
// the completed section of the designs
// like with wires, declare as many devices as you want to use

Wires:
  in1 -> myNand.in1, in2 -> myNand.in2,
  myNand.out -> out
;
// so you can connect the element's pins to the pins of the NAND
// make sure to reference the right part via its id, you declared

// again: CTRL+ENTER to check this design if you want




tï¿½Inputs: in1, in2;
Outputs: out;tï¿½	TUTORIAL2tÂ³Tutorial 2 - Specification
==========================

Description:
------------
Tutorial 1 showed you have basic wiring works, but this won't get you far. To build interesting designs you have to reuse other elements however.

In this tutorial we will build a NAND gate based on a NAND gate... for educational purposes only, of course!

Usually this specification would explain what a NAND gate does, but you'll find the NAND gate specification in the "Completed" designs section in the explorer. Head over there, read it and get back to the "Design" tab of this tutorial!  

After finishing this tutorial try to design the NOT gate under the "Tasks/" folder if you haven't already done so!ptï¿½nTests:
  0->in1, 0->in2, out->1;
  0->in1, 1->in2, out->1;
  1->in1, 0->in2, out->1;
  1->in1, 1->in2, out->0;xtï¿½
Tutorials\sqï¿½~ï¿½ï¿½ï¿½tÃžDesign Syntax
=============

This chapter explains the syntax used for creating designs. It does so by showing some examples and following up by a syntax specification.


Pins:
-----

Inputs and outputs have arbitrary choosen identifier like so:
  Inputs: inPin1, inPin2, abc;
  Outputs: outPin1, outPin2, outPin3, outPin4, def;

Parts consist of an arbitrary choosen identifier followed by a part type in all upper-case:
  Parts: myNand NAND, myNot NOT, anotherNand NAND, andAnAnd AND;

Wires can connect:
  Wires:
    inPin1 -> outPin1,       //inputs to outputs
    inPin1 -> myNot.in,      //inputs to part-inputs
    myNot.out -> outPin2,    //part-outputs to outputs
    myNot.out -> myNand.in1, //part-outputs to part-inputs
    1 -> outPin3,            //constants to output
    0 -> myNand.in2;         //constants to part-inputs

Only "1" or "0" can be used as constant. If any input pin has no wire attached to it, it will automatically get the input "0".
	
Busses:
-------

The examples so far involved only pins. If a design has to use many pins, busses can be used instead. To define a bus containing multiple pins, one can write:
  Inputs: inBus1[8], inBus2[8], inBusWide[16], inPin1;
  Outputs: outBus1[8], outBus2[8], outBusWide[16], outPin;
This way e.g. inBus1 is a bus with a bus width of 8 (meaning it contains 8 separate pins) and inBusWide has bus width of 16.

When specifying wires in the "Wires"-section, busses of same size can be connected:
  inBus1 -> outBus1

Single pins inside the bus can be selected and connected as well:
  inBus1[3] -> outPin
Connects the third pin of inBus1 to the outPin. Note that inBus1[3] represents a single pin in the "Wires"-section, while in the "Inputs"- and "Outputs"-section it would define a bus of size three. Also note that the numbering of the pins starts with "1" (no zero-based index).

It is possible to select not only a pin, but also a sub-bus of a bus:
  inBus1 -> outBusWide[9:16]
  inBus1[1:8] -> outBusWide[9:16]
Both lines mean the same thing. This connects inBus1[1] with outBusWide[9], inBus1[2] with outBusWide[10], etc. up to inBus1[8] with outBusWide[16].

A single pin can also be connected to a (sub-)bus (not vice versa). In this case the pin connects to all pins of that (sub-)bus
  inPin1 -> outBus1[2:4] //connects to sub-bus [2:4] 
  inPin1 -> outBus2      //connects to complete bus

When working with busses, it is important to know the proper notation of values. Let's say you have a bus "bus[8]" with value "00001111". This means that pin "bus[1]" has value "1" and pin "bus[8]" has value "0". Therefore you read the separate pins from right to left, when written as a binary number.


Formal Specification:
---------------------

A design consists of the "Inputs", "Outputs", "Parts" and "Wires" section:
[design] = [input_section] [output_section] [part_section] [wire_section]

Each section starts with a corresponding section identifier, followed by a colon, one or more of its corresponding elements and ends with a semicolon: 
[input_section]  = "Inputs:"  [input] (, [input])* ";"
[output_section] = "Outputs:" [output] (, [output])* ";"
[part_section]   = "Parts:"   [part] (, [part])* ";"
[wire_section]   = "Wires:"   [wire] (, [wire])* ";"

Inputs and outputs can be either single pins (in which case they consist of a simple identifier) or a busses (in which case their bus width has to be specified
[input]  = [input_pin_id]  | ([input_bus_id][bus_size])
[output] = [output_pin_id] | ([output_bus_id][bus_size])

Identifiers have to start with a letter optionally followed by an arbitrary amount of letters or numbers:
[input_pin_id]  = [id]
[output_pin_id] = [id]
[input_bus_id]  = [id]
[output_bus_id] = [id]
[id]            = [letter] ([letter | digit])*
[letter]        = "a"|...|"Z"
[digit]         = "0"|...|"9"

A bus size is given as a number in square brackets. A number has at least one digit.
[bus_size] = "[" [number] "]"
[number]   = [digit]+

Parts can be written as pairs of part identifiers and part types. Part types are always upper-case:
[part]             = [part_id] [part_type]
[part_id]          = [id]
[part_type]        = [uppercase_letter] ([uppercase_letter | digit])*
[uppercase_letter] = ("A"|...|"Z")

Wires have a start and end. Start and end can be regular pins, busses of the designed element or of its parts:
[wire]  = [start] "->" [end]
[start] = [pin_value] | [input_pin] | [input_bus] | [part_id]"."[output_pin] | [part_id]"."[output_bus]
[end]   = [output_pin] | [output_bus] | [part_id]"."[input_pin] | [part_id]"."[input_bus]

A pin can be either a reference to a pin id or a specific pin inside a bus:
[pin_value] = "0" | "1"
[input_pin]  = [input_pin_id] | [input_bus_id][pin_selection]
[output_pin] = [output_pin_id] | [output_bus_id][pin_selection]
[pin_selection] = "[" [number] "]"

A bus can be either a reference to a bus id or a group of pins inside a bus:
[input_bus]  = [input_bus_id] | [input_bus_id][bus_selection]
[output_bus] = [output_bus_id] | [output_bus_id][bus_selection]
[bus_selection] = "[" [number] ":" [number] "]"pptï¿½SYNTAXpppsqï¿½~ï¿½ï¿½ï¿½tJSequential Logic
================

This chapter explains relevant aspects of sequential logic.

If you change the input values of a NAND gate, it doesn't change its output values immediately, but instead it needs a short time to re-adjust. In extension this is true for all hardware elements based on the NAND gate.

When doing the verification this is considered by using a clock. Each clock cycle only one test is performed and the clock cycles are far apart enough, so that the whole hardware element has time to stabilize its outputs.

What is apparent though is that each clock cycle and therefore test is completely independent from the previous ones for non-sequential logic elements (like the NAND gate).

The D-Flip-Flop or DFF element however has a memory. Its output value is the input value of the last clock cycle. Therefore its output value is completely independent on its input value for the current clock cycle and instead it solely relies on its input value of the last clock cycle. This is what enables the design of memory elements.

However it also means that a test can't be done in a single test step or clock cycle anymore and instead you have to consider all test steps as a sequence. Therefore you might find test steps expecting an output value of "x" which simply means, that for that test step the output value is irrelevant.pptï¿½SEQUENTIALLOGICpppsqï¿½~ï¿½ï¿½ï¿½tÂ§Notational Systems
==================

This chapter explains aspects of different number notation systems used within the Microhard Development Environment.


Binary Notation:
----------------

When numbers are written in the context of hardware elements (for example with adders), then the binary notation is used. This way each binary digit corresponds to a pin. Note that when we write numbers, we always write the least significant digit on the right, which will in busses also be the pin indexed as "1".


Converting a number from binary to decimal:
-------------------------------------------

To convert a number from a binary to a decimal representation, we need to determine a value for each digit and add up those values. The value we assign each digit is:
x * 2^i
Where x is the value (either 1 or 0) and i is the position (indexed from right to left beginning with a zero).

For example the binary number "1010" would be converted as follow:

i: 3210
x: 1010

Result: 0*2^0 + 1*2^1 + 0*2^2 + 1*2^3 = 10


Converting a number from decimal to binary:
-------------------------------------------

When converting from decimal to binary notation we need to take the reverse approach.

1.  We need to find the smallest n for which 2^(n+1) is bigger than the decimal
    number x we want to convert.
2.  Now we check if our number is greater or equal than 2^n.
2a. If so, we subtract 2^n from x and write down the binary digit "1".
2b. Otherwise we don't change x and write down the binary digit "0".
3.  We subtract 1 from n and while n>=0 we go back to step 2.

For x=10 (decimal):
1. n=3, because 2^3<10<2^4
2. 10 >= 2^3, so our first digit is "1" and we set x = 10 - 2^3 = 2
3. 2 < 2^2, so our second digit is "0"
4. 2 >= 2^1, so our third digit is "1" and we set x = 2-2 = 0
5. 0 < 2^0, so our last digit is "0"
6. The resulting binary number is "1010"


Notation of negative binary numbers:
------------------------------------

When we build hardware elements which operate on numbers they have a fixed bus width. So even though the number "1" could be represented in one bit, we have 3 spare bits in a 4-Bit Adder (making the exact value "0001").

Negative numbers could be represented by taking the most left bit and using it as an indicator whether a number is negative. The better approach however is to use the two's complement form. In this form a number is positive or zero if the most left bit is "0" and a number is negative if the most left bit is "1". To make a number negative, we take its positive form, negate all bits and add "1" to the resulting number. This has the main advantage, that when adding up numbers, we don't need to care about whether they are positive or negative. The addition as described in the next section will always work and deliver the right result.

Adding binary numbers: 
----------------------
Adding up binary numbers is as easy as adding decimal numbers. You can write two numbers below each other and add them up. If the result is >1, you have to use a carry (like you would in the decimal system if two numbers added up were >=10).

For example the binary number "1010" (decimal value 10) and the binary number "11" (decimal value 3) can be added like this:

  1010
+ 0011
======
  1101 (decimal 13)
    x

Note that in the column marked "x" the 1+1=0 + carry, which is added in the next column. This works for positive, negative and mixed operands, when using two's complement form for negative numbers.


Hexadecimal Notation:
---------------------

The hexadecimal notation is used where 16-Bit busses are used. Converting from and to decimal notation works the same way as it does with the binary system, but instead of using the "2^?", use "16^?". Also since the hexadecimal system represents 16 values in one digit, but we now only 10 numbers (0 to 9), we use A,B,C,D,E,F for the values 10,11,12,13,14,15. Further when we write a hexadecimal number, we always write 0x in front of it, so we don't confuse it with a decimal number. Another advantage of hexadecimal notation is, that it breaks down nicely to the binary notation. 4 binary digits can be exactly expressed in 1 hexadecimal digit. Therefore no complicated conversion is necessary as it is with conversions involving the decimal system. pptï¿½NOTATIONALSYSTEMSpppxtï¿½Manual\xtï¿½
Documents\sqï¿½~ï¿½Â»ï¿½sqï¿½~ï¿½Â¹ï¿½ï¿½ï¿½wï¿½ï¿½ï¿½sqï¿½~ï¿½Â»ï¿½sqï¿½~ï¿½Â¹ï¿½ï¿½ï¿½wï¿½ï¿½ï¿½sqï¿½~ï¿½Â»sqï¿½~ï¿½Â¹ï¿½ï¿½ï¿½wï¿½ï¿½ï¿½qï¿½~ï¿½#qï¿½~ï¿½`qï¿½~ï¿½&xtï¿½Nand\sqï¿½~ï¿½Â»sqï¿½~ï¿½Â¹ï¿½ï¿½ï¿½wï¿½ï¿½ï¿½qï¿½~ï¿½Âqï¿½~ï¿½â€ qï¿½~ï¿½â‚¬xtï¿½Not\sqï¿½~ï¿½Â»sqï¿½~ï¿½Â¹ï¿½ï¿½ï¿½wï¿½ï¿½ï¿½qï¿½~ï¿½Â¡qï¿½~ï¿½Âµqï¿½~ï¿½Ëœxtï¿½And\sqï¿½~ï¿½Â»sqï¿½~ï¿½Â¹ï¿½ï¿½ï¿½wï¿½ï¿½ï¿½qï¿½~ï¿½Sqï¿½~ï¿½4qï¿½~ï¿½qï¿½~ï¿½Xqï¿½~ï¿½Æ’xtï¿½Or\sqï¿½~ï¿½Â»sqï¿½~ï¿½Â¹ï¿½ï¿½ï¿½wï¿½ï¿½ï¿½qï¿½~ï¿½Â°qï¿½~ï¿½â€ºqï¿½~ï¿½ xtï¿½Xor\xtï¿½Logic Circuits\sqï¿½~ï¿½Â»sqï¿½~ï¿½Â¹ï¿½ï¿½ï¿½wï¿½ï¿½ï¿½sqï¿½~ï¿½Â»sqï¿½~ï¿½Â¹ï¿½ï¿½ï¿½wï¿½ï¿½ï¿½qï¿½~ï¿½â€¹qï¿½~ï¿½7qï¿½~ï¿½Å¾qï¿½~ï¿½.xtï¿½Mux\sqï¿½~ï¿½Â»sqï¿½~ï¿½Â¹ï¿½ï¿½ï¿½wï¿½ï¿½ï¿½qï¿½~ï¿½)qï¿½~ï¿½Â«xtï¿½Demux\sqï¿½~ï¿½Â»sqï¿½~ï¿½Â¹ï¿½ï¿½ï¿½wï¿½ï¿½ï¿½qï¿½~ï¿½Â¦qï¿½~ï¿½qï¿½~ï¿½Nqï¿½~ï¿½Axtï¿½Adder\sqï¿½~ï¿½Â»sqï¿½~ï¿½Â¹ï¿½ï¿½ï¿½wï¿½ï¿½ï¿½qï¿½~ï¿½{qï¿½~ï¿½â€¢xtï¿½Alu\xtï¿½Advanced Circuits\sqï¿½~ï¿½Â»sqï¿½~ï¿½Â¹ï¿½ï¿½ï¿½wï¿½ï¿½ï¿½qï¿½~ï¿½sqï¿½~ï¿½Â»sqï¿½~ï¿½Â¹ï¿½ï¿½ï¿½wï¿½ï¿½ï¿½qï¿½~ï¿½Iqï¿½~ï¿½qï¿½~ï¿½1xtï¿½	Register\sqï¿½~ï¿½Â»sqï¿½~ï¿½Â¹ï¿½ï¿½ï¿½wï¿½ï¿½ï¿½qï¿½~ï¿½<qï¿½~ï¿½oxtï¿½Counter\sqï¿½~ï¿½Â»sqï¿½~ï¿½Â¹ï¿½ï¿½ï¿½wï¿½ï¿½ï¿½qï¿½~ï¿½qï¿½~ï¿½]xtï¿½Ram\xtï¿½Memory\qï¿½~ï¿½Dqï¿½~ï¿½xtï¿½
Completed\sqï¿½~ï¿½ï¿½ï¿½ppptï¿½Settingspppxsrï¿½java.lang.IntegerÃ¢Â Â¤Ã·Ââ€¡8ï¿½Iï¿½valuexrï¿½java.lang.Numberâ€ Â¬â€¢â€Ã â€¹ï¿½ï¿½xpï¿½ï¿½ï¿½ï¿½srï¿½java.lang.BooleanÃ râ‚¬Ã•Å“ÃºÃ®ï¿½Zï¿½valuexpï¿½sqï¿½~qï¿½~qï¿½~qï¿½~qï¿½~qï¿½~qï¿½~qï¿½~qï¿½~qï¿½~qï¿½~sqï¿½~ï¿½ï¿½ï¿½